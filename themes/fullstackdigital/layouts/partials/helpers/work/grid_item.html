{{ $size := .page.grid.columns | default "4" }}

<div class="container" id="loading_content" style="visibility: visible; display: block;">
<div class="masonry-container work-grid row-{{ $size }}">
<!-- <div class="gutter-guide"></div> -->

{{ $total := len .page.grid.items }}
{{ range $index, $grid_items := .page.grid.items }}
{{ $name := .name }}
{{ $order := $index }}

{{ range $index, $item := $.global.Site.Data.placeholder.work }}

{{ if eq .name $name }}
{{ $logo_src := .logo | default "/images/clients/color/quantum.svg" }}
{{ $logo := resources.Get $logo_src }}
{{ $thumb_src := .thumbnail | default "/images/placeholder/ddn-cover.png" }}
{{ $thumb := resources.Get $thumb_src }}

<div class='{{ with .tags }}{{ delimit . " " }}{{ end }} gridgrow'>
  <a class="work-link gridgrow-link" href='{{ .link | default "x" }}' title="{{ .title | safeHTML }}"><span>{{ .title | safeHTML }}</span></a>
  <div class="gridwrap background-night">

    <div class="flex-center gridgrow-image-holder" style="background-color: {{ .background }};">


      {{/* <div class="gridgrow-image lazyload lazypreload" data-bg='{{ $thumb.Permalink }}' style='background-position-y: 60%;'></div> */}}
      <img class="gridgrow-image lazyload lazypreload" calc-size='{{ $thumb.Permalink }}' data-src='{{ $thumb.Permalink }}' style='background-position-y: 60%;'>

      <div style="background-color: {{ .background }};" class="wipe">
      </div>
    </div>

  <div class="card-footer background-night color-white" itemprop="description">
  <div class="excerpt-group">
  <div class="card-logo-holder flex-center-vertical">
  <img class="card-logo" src="{{ $logo.Permalink }}">
  </div>
  <h6 class="gridgrow-excerpt strip-margin">{{ .title | safeHTML }}</h6>
    <span class="card-footer-layer flex h_children_center hover-right">
      <h6 class="gridgrow-view strip-margin">View Case Study</h6>
      <svg class="color-white" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="32px" height="32px" viewBox="0 0 64 64" enable-background="new 0 0 64 64" xml:space="preserve">
      <g>
      <line fill="none" stroke="#ffffff" stroke-width="2" stroke-miterlimit="10" x1="0" y1="32" x2="63" y2="32"></line>
      </g>
      <polyline fill="none" stroke="#ffffff" stroke-width="2" stroke-linejoin="bevel" stroke-miterlimit="10" points="54,41 63,32 
                        54,23 "></polyline>
      </svg>
    </span>
  </div>
  
  </div>
  </div>
</div>
{{ end }}
{{ end }}
{{ end }}

</div>
<div class="container-m spacer"></div>
</div>
<div class="work-ajax"></div>

{{ $velocity := resources.Get "js/plugins/velocity.min.js" | minify }}
{{ $scroll_lock := resources.Get "js/plugins/bodyScrollLock.js" | minify }}

<script type="text/javascript" src="{{ $velocity.Permalink }}"></script>
<script type="text/javascript" src="{{ $scroll_lock.Permalink }}"></script>
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/barba.js/1.0.0/barba.min.js"></script> -->
<script type="text/javascript">

document.addEventListener("DOMContentLoaded", function(){
  //console.log(ajaxRequest);
  gridImageSize();
  animateGrid();

  
});


function gridImageSize(){
  // FIX THIS BEHAVIOR: 
  // If grid image is expanded and window resized, the expanded image resizes. The initial values should resize, but not the currently active image.
  let gridItem = document.querySelectorAll(".gridgrow");
  let gridImage = document.querySelectorAll(".gridgrow-image");
  let gridgrowHeight = document.querySelector(".gridgrow-image-holder").offsetHeight;
  let gridgrowWidth;

  // Barba.Pjax.Dom.wrapperId = "crit";
  // Barba.Pjax.Dom.containerClass = "page_critical_css";
  // console.log(Barba.Pjax.Dom.containerClass);

  // Barba.Pjax.start();

  gridItem.forEach(function(item, index){
    let image = item.querySelector(".gridgrow-image");
    let imageWrapper = item.querySelector(".gridgrow-image-holder");
    let wrapperMargin = parseInt(getComputedStyle(imageWrapper).marginTop);
    let gridLink = item.querySelector("a");

    gridgrowWidth = item.offsetWidth;
    // image.style.height = gridgrowHeight * .7 + "px";
    // image.style.width = gridgrowWidth * .7 + "px";
    image.addEventListener('load', () => {
      let ratio = image.naturalHeight / imageWrapper.offsetHeight;
      let imageHeight = (image.naturalHeight / ratio) * .7;
      let imageWidth = (image.naturalWidth /ratio) * .7;

      image.style.height = imageHeight + "px";
      image.style.width = imageWidth + "px";
    
      //console.log(gridgrowWidth);
      image.style.top = (imageWrapper.offsetHeight - wrapperMargin - imageHeight) / 2 + "px";
      image.style.left = (imageWrapper.offsetWidth - imageWidth) / 2 + "px";
      console.log("height: " + imageHeight);
    });
    
  });
}

// On click, grow the grid item and load the content
// On close, reverse the animation and hide the loaded content

function animateGrid(){
  // Get a target element that you want to persist scrolling for (such as a modal/lightbox/flyout/nav). 
  const targetElement = document.querySelector("#barba-wrapper");

  let workAjax = document.querySelector(".work-ajax");
  let gridItems = document.querySelectorAll(".gridgrow");
  let gridLinks = document.querySelectorAll(".gridgrow a");

  const gridContainer = document.querySelector(".container");
  const gridContainerPadding = parseInt(getComputedStyle(gridContainer).paddingLeft)+ parseInt(getComputedStyle(gridContainer).paddingRight);

  const container = document.querySelector(".container-m.spacer");
  const containerPadding = parseInt(getComputedStyle(container).paddingLeft) + parseInt(getComputedStyle(container).paddingRight);
  const containerWidth = parseInt(getComputedStyle(container).width) - containerPadding;
  console.log("containerWidth: " + containerWidth);
  const navHeight = document.querySelector(".masthead").offsetHeight;
  //animateItem();
  const grid = document.querySelector(".work-grid");
  const pageUrl = window.location;
  initialGridState();
  function initialGridState(e) {
    gridItems.forEach(function(item, index) {

      // I need to grab some starting values ON CLICK
      // Needs to be on click because some positions are based on the scroll offset
        let gridgrowWidth = item.offsetWidth;
        let animateClick = function (e) {

          (e || window.event).preventDefault();
          //e.preventDefault();

          
          bodyScrollLock.disableBodyScroll(targetElement);
          
          // 2. ...in some event handler after showing the target element...disable body scroll
          
          // 3. ...in some event handler after hiding the target element...
          //bodyScrollLock.enableBodyScroll(targetElement);
          let wipe = item.querySelector(".wipe");
          let wipeParent = item.querySelector(".gridgrow-image-holder");
          let itemImage = item.querySelector(".gridgrow-image");
          // 4. Useful if we have called disableBodyScroll for multiple target elements,
          // and we just want a kill-switch to undo all that.
          //bodyScrollLock.clearAllBodyScrollLocks();
          let scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
          
          console.log("scroll width: " + scrollbarWidth);

          let initialValue = {
            wrapperMarginTop: parseInt(getComputedStyle(wipeParent).marginTop),
            wrapperMarginLeft: -(parseInt(getComputedStyle(wipeParent).marginLeft)),
            containerPaddingLeft: containerPadding / 2,
            gridContainerPaddingLeft: gridContainerPadding / 2,
            wipe: {
              width: wipeParent.offsetWidth,
              height: wipeParent.offsetHeight,
              translateX: "0px",
              translateY: "0px",
              left: "0.1px",
              top: "0.1px",
              duration: 100,
              delay: 0,
              easing: "swing",
              z: wipe.style.zIndex,
            },
            item: {
              width: parseInt(itemImage.style.width),
              height: parseInt(itemImage.style.height),
              translateX: "0px",
              translateY: "0px",
              left: parseInt(itemImage.style.left),
              top: itemImage.offsetTop,
              backgroundPositionY: "60%",
              duration: 400,
              delay: 50,
              easing: "swing",
              z: itemImage.style.zIndex,
            },
            content: {
              top: 0,
            }
          }
          //enable it again
          console.log(e.currentTarget);
          console.log(initialValue.wrapperMarginLeft);
          console.log("initial values:");
          console.log(initialValue);
          item = e.currentTarget;
          
          reverse = false
          item.removeEventListener("click", animateClick, false);
          animateItem(item, animateClick, initialValue, reverse);
        }

        item.addEventListener("click", animateClick, false);
    }); 
  }
  
  // window.addEventListener("resize", function() {
  //   //gridImageSize();
  //   initialGridState();
  // });

function animateItem(item, animateClick, initialValue, reverse) {
  
  
  // don't want image to trigger click again
  //item.removeEventListener("click", animateClick, false);
  console.log("ANIMATION ITEM START ---------------------");
  console.log("initial values:");
  console.log(initialValue);

      wipe = item.querySelector(".wipe");
      itemImage = item.querySelector(".gridgrow-image");

        // the final velocity values. To reverse animation, 
        let endValue = {
          wrapperMarginTop: "",
          wrapperMarginLeft: "",
          wipe: {
              width: window.innerWidth,
              height: (window.innerHeight) + (window.innerHeight * .2),
              translateX: -(item.offsetLeft + item.offsetParent.offsetLeft) - window.scrollX,
              translateY: -((item.offsetTop + grid.offsetParent.offsetTop + initialValue.wrapperMarginTop) - window.scrollY - navHeight),
              left: "0px",
              top: "0px",
              duration: 500,
              delay: 50,
              easing: "swing",
              z: 888
            },
            item: {
              width: initialValue.item.width * (containerWidth / initialValue.item.width),
              height: initialValue.item.height * (containerWidth / initialValue.item.width),
              // gridContainerPadding 20
              // 20 - 20 + 80 + 125 - 21 - 80
              translateX: -(item.offsetLeft - initialValue.gridContainerPaddingLeft + initialValue.item.left - initialValue.wrapperMarginLeft) + container.offsetLeft,
              translateY: -((item.offsetTop + grid.offsetParent.offsetTop + initialValue.wrapperMarginTop ) - window.scrollY - navHeight),
              top: "0px",
              duration: 500,
              delay: 50,
              easing: "swing",
              z: 999
            },
            content: {
              top: 0,
            }
        }
      console.log("MATH:")
      console.log(initialValue.wrapperMarginLeft);
      console.log("end values:");
      console.log(endValue);
      // change start values based on if the animation is being reversed
      let startValue
      if (reverse) {
        
        startValue = endValue;
        endValue = initialValue;
        item.classList.remove("active");
        
        
        
      } else {
        startValue = initialValue;
        endValue = endValue;
        item.classList.add("active");
        itemImage.style.zIndex = 999;
        wipe.style.zIndex = 888;
        item.style.overflow = "visible";
        item.querySelector(".gridwrap").style.overflow = "visible";
        item.querySelector(".gridgrow-image-holder").style.overflow = "visible";
      }

      // Start ajax loading the content
      ajaxWorkItem(item, animateClick, initialValue, endValue, reverse);
      
    wipe.velocity({
      width: [endValue.wipe.width, startValue.wipe.width],
      height: [endValue.wipe.height, startValue.wipe.height],
      transform: [`translateX(${endValue.wipe.translateX}px) translateY(${endValue.wipe.translateY}px)`, `translateX(${startValue.wipe.translateX}px) translateY(${startValue.wipe.translateY}px)`],
      //transform: [endValue.scale, startValue.scale],
      left: [endValue.wipe.left, startValue.wipe.left],
      top: [endValue.wipe.top, startValue.wipe.top],
    }, 
    {
      delay: startValue.wipe.delay,
      duration: startValue.wipe.duration,
      easing: startValue.wipe.easing,
      /* Velocity's default options */
    });

    itemImage.velocity({
      transform: [`translateX(${endValue.item.translateX}px) translateY(${endValue.item.translateY}px)`, `translateX(${startValue.item.translateX}px) translateY(${startValue.item.translateY}px)`],
      //left: [`-${itemOffsetLeft}px`, `${itemOffsetLeft}px`],
      top: [endValue.item.top, startValue.item.top],
      bottom: [endValue.item.bottom, startValue.item.bottom],
      "background-position-y": [endValue.item.backgroundPositionY, startValue.item.backgroundPositionY],
      width: [endValue.item.width, startValue.item.width],
      height: [endValue.item.height, startValue.item.height]
    }, 
    {
      duration: startValue.item.duration,
      delay: startValue.item.delay,
      easing: startValue.item.easing,
      queue: "",
      loop: false,
      mobileHA: true,
      /* Velocity's default options */
      progress: function(elements, complete, remaining, start, tweenValue) {
        console.log(complete);
        if (complete === 1) {
          AOS.refresh();
          if (reverse) {
            item.style.overflow = "";
            item.querySelector(".gridwrap").style.overflow = "";
            item.querySelector(".gridgrow-image-holder").style.overflow = "";
            
            //gridImageSize();
            //initialGridState();
            bodyScrollLock.enableBodyScroll(targetElement);
            item.addEventListener("click", animateClick, false);
            itemImage.style.zIndex = "";
            wipe.style.zIndex = "";

          } else {
            reverseAnimation(item, initialValue, startValue, endValue, animateClick);
          }
        }
      }
    });

    
    
}
    function reverseAnimation(item, initialValue, startValue, endValue, animateClick) {
      //window.location.href = window.location.origin;
      
      let reverseBtn = document.createElement("div");
      reverseBtn.classList.add("reverseAnimation");
      reverseBtn.innerHTML = `<span>Close</span><i class="fa fa-window-close" aria-hidden="true"></i>`;

      //reverseBtn.appendChild(t);
      document.body.appendChild(reverseBtn);

      //detect back btn then hijack it
      window.onpopstate = function(event) {
        window.history.pushState("object or string", "Title", pageUrl);
        reverseClick();
      }

      function reverseClick(e) {

        reverse = true;

        let element = document.querySelector(".reverseAnimation");
        element.parentNode.removeChild(element);

        animateItem(item, animateClick, initialValue, endValue, reverse);
        //clicky();
      }
      reverseBtn.addEventListener("click", reverseClick, false);     
          
    }
    function ajaxWorkItem (item, animateClick, initialValue, endValue, reverse) {

      if (reverse) {
        workAjax.innerHTML = "";
        workAjax
        .velocity({
          opacity: 0,
          visibility: ["hidden", "visible"]
        }, {
          duration: 400,
        })
        .velocity({
          display: "none",
        }, {
          duration: 0,
        });
      } else {
        let nextLink = item.querySelector("a").getAttribute("href");
          
        //https://stackoverflow.com/questions/36631762/returning-html-with-fetch
        // AJAX CALL
        
          fetch(nextLink /*, options */)
          .then((response) => response.text())
          .then((html) => {
              let parser = new DOMParser();

              // Parse the text
              var doc = parser.parseFromString(html, "text/html");
              var docArticle = doc.querySelector('main').innerHTML;
              workAjax.innerHTML = docArticle;
              //console.log(html);
              window.history.pushState("object or string", "Title", nextLink);
              
          })
          .catch((error) => {
              console.warn(error);
          });
          workAjax.velocity({
            top: [navHeight, 0],
            display: ["block", "none"]
          })
          workAjax
            .velocity({
              opacity: [1, 0],
              visibility: ["visible", "hidden"]
            }, {
              delay: 400,
              duration: 400,
            });
      }
      
    }

}

</script>