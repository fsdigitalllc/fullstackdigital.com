{{ $size := .page.grid.columns | default "4" }}
{{ $tabs := .page.grid.tabs | default true }}
{{ $layout := .page.grid.layout | default "grid" }}
{{ $featured := false }}
{{ if eq $layout "row" }}
  {{ $size = "1" }}
  {{ $featured = true }}
{{ end }}
{{ if eq $tabs true }}
<div class="work-grid-tabs container padding-s-bottom">
  <div class="flex h_children_space-between">
    <div class="brand active" data-filter="brand">
        <svg class="padding-xs-bottom" id="Layer_1" width="44" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
          <path stroke-width="2" stroke-miterlimit="10" d="M1,21c0,20,31,38,31,38s31-18,31-38  c0-8.285-6-16-15-16c-8.285,0-16,5.715-16,14c0-8.285-7.715-14-16-14C7,5,1,12.715,1,21z"></path>
          </svg>
        <span>Brand</span>
      </div>
      <div class="web" data-filter="web">
          <svg id="Layer_1" width="44" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
            <g>
            <rect x="1" y="10" stroke-width="2" stroke-miterlimit="10" width="62" height="41"></rect>
            <line stroke-width="2" stroke-miterlimit="10" x1="22" y1="63" x2="42" y2="63"></line>
            <line stroke-width="2" stroke-miterlimit="10" x1="32" y1="63" x2="32" y2="51"></line>
            </g>
            <line stroke-width="2" stroke-miterlimit="10" x1="1" y1="43" x2="64" y2="43"></line>
            </svg>
          <span>Web</span>
        </div>
        <div class="market" data-filter="market">
          <svg id="Layer_1" width="44" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
            <polygon stroke-width="2" stroke-miterlimit="10" points="26,49.042 54.963,49.042 54.963,11.042   1,11.042 1,49.042 14,49.042 14,59.486 "></polygon>
            <polyline stroke-width="2" stroke-miterlimit="10" points="57,41.042 62.963,41.042 62.963,3.042   9,3.042 9,9 "></polyline>
            </svg>
          <span>Market</span>
        </div>  
        </div>
</div>

{{ end }}
<div class="container work-{{ $layout }}" id="loading_content" style="visibility: visible; display: block;">
<div class="work-container row-{{ $size }}">
<!-- <div class="gutter-guide"></div> -->

{{ $query := (where $.global.Site.RegularPages "Section" "work") }}
{{ if $featured }}
  {{ $query = first 4 (sort (where (where $.global.Site.RegularPages "Section" "work") ".Params.grid_item.featured" "==" true) ".Params.grid_item.weight" "asc") }}
{{ end }}
{{ range $query }}

{{ $tag := "" }}
{{ if in .Path "market" }}
  {{ $tag = "market" }}
{{ end }}
{{ if in .Path "web" }}
  {{ $tag = "web" }}
{{ end }}
{{ if in .Path "brand" }}
  {{ $tag = "brand" }}
{{ end }}
<!--way too much effort to grab the client logo for the grid item-->
{{ $prefix := "assets/images/clients/" }}
{{ $asset_prefix := "images/clients/" }}
{{ $context := .Params.stacks_hero }}
{{ $image := .Resources.GetMatch $context.image }}
{{ $logo := "" }}
{{ $name := $context.client }}
  {{ if $featured }}
    {{ $prefix = "assets/images/clients/grey/" }}
    {{ $asset_prefix = "images/clients/grey/" }}
  {{ else if or (eq .Params.grid_item.logo_color "color") (eq .Params.grid_item.logo_color true ) }}
    {{ $prefix = "assets/images/clients/color/" }}
    {{ $asset_prefix = "images/clients/color/" }}
  {{ else if or (eq .Params.grid_item.logo_color "white") (eq .Params.grid_item.logo_color false ) }}
    {{ $prefix = "assets/images/clients/white/" }}
    {{ $asset_prefix = "images/clients/white/" }}
  {{ else if or (eq .Params.grid_item.logo_color "black") }}
    {{ $prefix = "assets/images/clients/black/" }}
    {{ $asset_prefix = "images/clients/black/" }}
  {{ end }}
  
{{ range $.global.Site.Data.lookup.clients }}
  {{ if eq .name $name }}
    {{ $logo = .image }}
  {{ end }}
{{ end }}

{{ $path := print $prefix $logo }}
{{ $assetpath := print $asset_prefix $logo }}
<div{{ if $featured }} style="background-color: {{ .Params.stacks_hero.background_color | safeHTML }};"{{ end }} class='gridgrow' data-item-filter="{{ $tag }}">
  <a class="work-link gridgrow-link" href='{{ .URL }}' title=""><span>{{ .Title | safeHTML }}</span></a>
  {{ if $featured }}
  <div style="background-color: {{ .Params.stacks_hero.background_color | safeHTML }};" class="wipe"></div>
  {{ end }}
  <div{{ if $featured }} style="background-color: {{ .Params.stacks_hero.background_color | safeHTML }};"{{ end }} class="gridwrap background-light">

    <div class="flex-center gridgrow-image-holder" style="background-color: {{ .Params.stacks_hero.background_color | safeHTML }};">


      {{/* <div class="gridgrow-image lazyload lazypreload" data-bg=''></div> */}}
      <img class="gridgrow-image lazyload lazypreload {{ $name }}" calc-size='' data-src='{{ $image.Permalink }}'>

      {{ if eq $featured false }}
      <div style="background-color: {{ .Params.stacks_hero.background_color | safeHTML }};" class="wipe"></div>
      {{ end }}
      
    </div>

  <div{{ if $featured }} style="background-color: {{ .Params.stacks_hero.background_color | safeHTML }};"{{ end }} class="card-footer" itemprop="description">
  <div class="excerpt-group">
  <div class="card-logo-holder flex-center-vertical">
  {{ if (fileExists $path) }}
  {{ $imagesrc := resources.Get $assetpath }}
  <img class="card-logo lazyload lazypreload {{ $name }}" src="{{ $imagesrc.Permalink }}">
  {{ end }}
  </div>
  {{ if $featured }}
    <h2 class="color-white">{{ .Params.grid_item.featured_title | safeHTML | default "FEATURED TITLE" }}</h2>
    <h3>{{ .Params.grid_item.featured_caption | safeHTML | default "FEATURED TITLE" }}</h3>
    <a class="button fill white" href='{{ .URL }}'>Read the Story</a>
    <h6 class="gridgrow-excerpt strip-margin">{{ .Title | safeHTML }}</h6>
  
    <span class="card-footer-layer flex h_children_center hover-right">
      <h6 class="gridgrow-view strip-margin">View Case Study</h6>
      <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="32px" height="32px" viewBox="0 0 64 64" enable-background="new 0 0 64 64" xml:space="preserve">
      <g>
      <line fill="none" stroke-width="2" stroke-miterlimit="10" x1="0" y1="32" x2="63" y2="32"></line>
      </g>
      <polyline fill="none" stroke-width="2" stroke-linejoin="bevel" stroke-miterlimit="10" points="54,41 63,32 
                        54,23 "></polyline>
      </svg>
    </span>
  {{ else }}
    <h6 class="gridgrow-excerpt strip-margin">{{ .Title | safeHTML }}</h6>
  
    <span class="card-footer-layer flex h_children_center hover-right">
      <h6 class="gridgrow-view strip-margin">View Case Study</h6>
      <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="32px" height="32px" viewBox="0 0 64 64" enable-background="new 0 0 64 64" xml:space="preserve">
      <g>
      <line fill="none" stroke-width="2" stroke-miterlimit="10" x1="0" y1="32" x2="63" y2="32"></line>
      </g>
      <polyline fill="none" stroke-width="2" stroke-linejoin="bevel" stroke-miterlimit="10" points="54,41 63,32 
                        54,23 "></polyline>
      </svg>
    </span>
    {{ end }}
  </div>
  
  </div>
  </div>
  
</div>

{{ end }}
</div>

</div>
<div class="container-m spacer"></div>
<div class="height-spacer"><div id="project-summary" class="container padding-m-top padding-m-bottom flex h_children_space-between break-t"><div class="col-3 t-col-8 grid"><img class="client_logo lazypreload lazyloaded" src=""><div class="flex tiny color-oil padding-s-top strip-padding-tablet h_children_space-between"><ul><li class="active">Brand</li><li class="active">Development</li><li class="active">Identity</li><li>Strategy</li></ul><ul><li>Web</li><li>Experience</li><li>Design</li><li>Development</li></ul><ul><li>Market</li><li>Search</li><li>Content</li><li>Social</li></ul></div></div><div class="col-8 flex v_c-center maxwidth-s t-col-12"><h1 class="page-title strip-margin-bottom color-oil"></h1></div></div></div>
<div class="work-ajax"></div>

{{ $velocity := resources.Get "js/plugins/velocity.min.js" | minify }}
{{ $scroll_lock := resources.Get "js/plugins/bodyScrollLock.js" | minify }}

<script type="text/javascript" src="{{ $velocity.Permalink }}"></script>
<script type="text/javascript" src="{{ $scroll_lock.Permalink }}"></script>
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/barba.js/1.0.0/barba.min.js"></script> -->
{{ if eq $tabs true }}
<script type="text/javascript">
console.log("Tabs loaded----------");
let filterBtns = document.querySelectorAll('[data-filter]');
let filterItems = document.querySelectorAll('[data-item-filter]');
  filterBtns.forEach(function(button, index) {

    let buttonAttr = button.getAttribute("data-filter");
    // console.log("buttonAttr");
    // console.log(buttonAttr);
    
    button.addEventListener("click", function(){
      sortItems(button, buttonAttr);
    });

    if (button.classList.contains("active")) {
      sortItems(button, buttonAttr);
    }
  });
  
  function sortItems(button, buttonAttr) {
    console.log("sorting " + button.innerText);

    filterItems.forEach(function(filterItem, index) {
      
      let absWidth;
      if (filterItem.classList.contains("loaded") ) {
        absWidth = filterItem.offsetWidth;
        console.log(absWidth);
      }
      let filterItemAttr = filterItem.getAttribute("data-item-filter");
      
      if (buttonAttr === filterItemAttr) {
        filterItem.style.width = "";
        filterItem.style.visibility = "visible";
        filterItem.style.position = "";
        filterItem.querySelector(".gridgrow-image").style.zIndex = "";
      } else {
        filterItem.style.width = 525 + "px";
        filterItem.style.visibility = "hidden";
        filterItem.style.position = "absolute";
        filterItem.querySelector(".gridgrow-image").style.zIndex = -1;
      }
      
    });

  }
  
</script>
{{ end }}
{{ if eq $featured true }}
<script type="text/javascript">
console.log("featured items loaded");
let gridItems = document.querySelectorAll(".gridgrow");
let container = document.querySelector(".container");

positionCaption();

window.addEventListener("resize", () => {
  positionCaption();
});

function positionCaption () {

  gridItems.forEach(item => {
    let gridCaption = item.querySelector(".excerpt-group");
    let image = item.querySelector(".gridgrow-image");

    console.log(image);
    gridCaption.style.left = container.offsetLeft + parseFloat(getComputedStyle(container).paddingLeft) + "px";
    gridCaption.style.position = "absolute";

    if (image.classList.contains("ddn")) {
      image.style.top = -50 + "px";
    } else if (image.classList.contains("rigado")) {
      image.style.top = 50 + "px";
    } else {
      image.style.top = 50 + "px";
    }
    
  });

}


</script>
{{ end }}
<script type="text/javascript">

// Alternative to DOMContentLoaded event
document.onreadystatechange = function () {
  if (document.readyState === 'interactive') {
    ajaxGrid();
    console.log("DOMContentLoaded... Starting Ajax Grid");
  }
}
// document.addEventListener("DOMContentLoaded", function(){
//   //console.log(ajaxRequest);
//   ajaxGrid();
  
// });


function ajaxGrid(){


// get all of the selectors we are working with.
let gridItems = document.querySelectorAll(".gridgrow");
let gridImages = document.querySelectorAll(".gridgrow-image");
let workAjax = document.querySelector(".work-ajax");
let heightSpacer = document.querySelector(".height-spacer");
let gridLinks = document.querySelectorAll(".gridgrow a");
let body = document.querySelector("body");
let gridContainer = document.querySelector(".container");
let container = document.querySelector(".container-m.spacer");
let grid = document.querySelector(".work-container");
let scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
let mobileScrollbar;
let featured;

if (scrollbarWidth === 0) {
  console.log("no scrollbarwidth");
  mobileScrollbar = 20;
} else {
  mobileScrollbar = 0;
}

if (grid.classList.contains("row-1")) {
  featured = true;
} else {
  featured = false;
}
let targetElement = document.querySelector("body");

gridImageSize();

function gridImageSize(){

// FIX THIS BEHAVIOR: 
// If grid image is expanded and window resized, the expanded image resizes. The initial values should resize, but not the currently active image.

let gridgrowWidth;
//BEN NOTE:
// get count of all images
// compare the count of all images to images loaded
// run the next function when all loaded
// just show loading indicator for the page untill the items finish.

//console.log(gridImageCount);
//console.log("count of images: " + gridImages.length);
gridImages.forEach(function(image, imageLoaded = 0) {
  // console.log(image);
  // console.log("loaded " + image);
  image.addEventListener('load', () => {
    // if (image.classList.contains("lazyloaded")) {
      console.log(image);
      imageLoaded++;
      let item = image.parentElement.parentElement.parentElement;
      let link = item.querySelector("a");
      item.classList.add("loaded");

      // resize the image as it loads
      //setImageSize(image, item);
      //console.log("resizing");
      //animateGrid();
      clicked = false;
      reverse = false;
      calcStart(item, clicked, reverse);

      if ( imageLoaded === gridImages.length ) {
        //console.log("----- All Images Loaded Image Loaded.... run animate grid ");
        //console.log(imageLoaded);
        // Grid can be animated now since all initial values are set
        //animateGrid();
      } else {
        //console.log(`Not all images loaded yet -----${gridImages.length - imageLoaded} left to load.`);
      }
    // }
    
      window.addEventListener("resize", function(){
      //console.log(ajaxRequest);
        //setImageSize(image, item);
        console.log("resizing FORWARD");
        //animateGrid();
        clicked = false;
        reverse = false;
        calcStart(item, clicked, reverse);
      });
    window.addEventListener("scroll", function(){
       itemViewport(item);
    });
    
    function heightSpacerContent(item){
      let logoImage = item.querySelector(".card-logo");
      let spacerLogo = heightSpacer.querySelector(".client_logo");
      let itemExcerpt = item.querySelector(".gridgrow-excerpt");
      let spacerTitle = heightSpacer.querySelector(".page-title");
      spacerLogo.src = logoImage.src;
      spacerTitle.innerText = itemExcerpt.innerText;
    }
    
    function itemViewport(item){
      var isInViewport = function (elem) {
      var bounding = elem.getBoundingClientRect();
      return (
          bounding.top >= 0 &&
          bounding.left >= 0 &&
          bounding.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
          bounding.right <= (window.innerWidth || document.documentElement.clientWidth)
          );
      };

      if (isInViewport(item)) {
          // Do something...
          //console.log("in viewport");
          //console.log(item);
          heightSpacerContent(item);
      }
    }

    item.addEventListener("click", function(e){
    //console.log(ajaxRequest);
    item = e.currentTarget;
    
    heightSpacerContent(item);
    //console.log("clicked");
    e.preventDefault();
    

    clicked = true;
    reverse = false;
      calcStart(item, clicked, reverse);
      //animateClick(item, initialValue);
    });

    //maybe animate the bottom half of the item on hover
    // item.addEventListener("mouseover", () => {
    //   item.velocity({
    //     "overflow": "visible"
    //   }, {
    //     delay: 0,
    //   });
    // });
  });

  
});
}

let pageUrl = window.location;

function calcStart(item, clicked, reverse) {

    
    console.log("setimagesize");
    let image = item.querySelector(".gridgrow-image");
    let imageWrapper = image.parentNode;
    let wrapperMargin = parseFloat(getComputedStyle(imageWrapper).marginTop);
    let ratio = image.naturalHeight / imageWrapper.offsetHeight;
    let imageHeight;
    let imageWidth;
    let wipe = item.querySelector(".wipe");
    let wipeParent = item.querySelector(".gridgrow-image-holder");
    let wipeWidth;
    let wipeHeight;
    
      if (featured) {

      wipeWidth = item.offsetWidth;
      wipeHeight = item.offsetHeight;

      imageHeight = (image.naturalHeight / ratio) * 1;
      imageWidth = (image.naturalWidth / ratio) * 1;

        if (clicked === false) {
          image.style.left = (imageWrapper.offsetWidth - imageWidth) / 2 + "px";
        }

      if (imageWidth > imageWrapper.offsetWidth) {
        imageHeight = (image.naturalHeight / ratio) * .9;
        imageWidth = (image.naturalWidth / ratio) * .9;
      }
      if (image.classList.contains("ddn")) {
        imageHeight = (image.naturalHeight / ratio) * 1.2;
        imageWidth = (image.naturalWidth / ratio) * 1.2;
      } else if (image.classList.contains("rigado")) {
        imageHeight = (image.naturalHeight / ratio) * 1.2;
        imageWidth = (image.naturalWidth / ratio) * 1.2;
        image.style.left = -50 + "px";
      }

      image.style.right = 0;
      ratio = image.naturalWidth / imageWrapper.offsetWidth;
      image.style.height = imageHeight + "px";
      image.style.width = imageWidth + "px";
      
    } else {
      wipeWidth = item.querySelector(".gridgrow-image-holder").offsetWidth;
      wipeHeight = item.querySelector(".gridgrow-image-holder").offsetHeight;

      imageHeight = (image.naturalHeight / ratio) * .7;
      imageWidth = (image.naturalWidth / ratio) * .7;
      
      if (imageWidth > imageWrapper.offsetWidth) {
        imageHeight = (image.naturalHeight / ratio) * .6;
        imageWidth = (image.naturalWidth / ratio) * .6;
      }
      if (clicked === false) {
        image.style.left = (imageWrapper.offsetWidth - imageWidth) / 2 + "px";
      }
      if (!item.classList.contains("active")) {
        console.log(imageWrapper.offsetHeight);
        //console.log(gridgrowWidth);
        image.style.top = (imageWrapper.offsetHeight - wrapperMargin - imageHeight) / 2 + "px";
        image.style.height = imageHeight + "px";
        image.style.width = imageWidth + "px";
        //console.log("height: " + imageHeight);
      }
    }
    
    
    //console.log("calcstart");
    //console.log(item);
    // I need to grab some starting values ON CLICK
    // Needs to be on click because some positions are based on the scroll offset
    let gridgrowWidth = item.offsetWidth;
    
    //console.log("RESIZING");
    
    let itemImage = item.querySelector(".gridgrow-image");
    let body = document.querySelector("body");
    let main = document.querySelector("main");
    // 4. Useful if we have called disableBodyScroll for multiple target elements,
    // and we just want a kill-switch to undo all that.
    //bodyScrollLock.clearAllBodyScrollLocks();
    
    //console.log("itemImage");
    //console.log(itemImage);
    let gridContainerPadding = parseFloat(getComputedStyle(gridContainer).paddingLeft)+ parseFloat(getComputedStyle(gridContainer).paddingRight);
    let containerPadding = parseFloat(getComputedStyle(container).paddingLeft) + parseFloat(getComputedStyle(container).paddingRight);
    let containerWidth = parseFloat(container.offsetWidth) - containerPadding;
    //console.log("containerWidth: " + containerWidth);
    
    let imgTop = 355;

    let navHeight = document.querySelector(".masthead").offsetHeight;
    let initialValue = {
        containerOffsetLeft: container.offsetLeft + parseFloat(getComputedStyle(container).paddingLeft),
        windowWidth: window.innerWidth,
        windowHeight: window.innerHeight,
        windowScrollX: window.scrollX,
        windowScrollY: window.scrollY,
        scrollbarWidth: scrollbarWidth,
        mobileScrollbar: parseFloat(mobileScrollbar),
        navHeight: document.querySelector(".masthead").offsetHeight,
        gridContainerPadding: parseFloat(getComputedStyle(gridContainer).paddingLeft)+ parseFloat(getComputedStyle(gridContainer).paddingRight),
        containerPadding: parseFloat(getComputedStyle(container).paddingLeft) + parseFloat(getComputedStyle(container).paddingRight),
        containerWidth: parseFloat(container.offsetWidth) - containerPadding,
        wrapperMarginTop: parseFloat(getComputedStyle(wipeParent).marginTop),
        wrapperMarginLeft: -(parseFloat(getComputedStyle(wipeParent).marginLeft)),
        containerPaddingLeft: containerPadding / 2,
        gridContainerPaddingLeft: gridContainerPadding / 2,
        gridContainerOffsetLeft: gridContainer.offsetLeft,
        heightSpacerHeight: heightSpacer.offsetHeight,
        wipe: {
          width: wipeWidth,
          height: wipeHeight,
          translateX: "0px",
          translateY: "0px",
          left: "0.1px",
          top: "0.1px",
          duration: 100,
          delay: 0,
          easing: "swing",
          z: wipe.style.zIndex,
        },
        item: {
          width: imageWidth,
          height: imageHeight,
          translateX: "0px",
          translateY: "0px",
          offsetLeft: wipeParent.offsetLeft,
          left: parseFloat(itemImage.style.left),
          top: itemImage.offsetTop,
          backgroundPositionY: "60%",
          duration: 400,
          delay: 50,
          easing: "swing",
          z: itemImage.style.zIndex,
        },
        content: {
          top: 0,
          imgTop: imgTop,
        }
      }
        
      //console.log("START OFFSET LEFT:");
      console.log("offset leftt:" + initialValue.containerOffsetLeft);
      //console.log(initialValue.mobileScrollbar, item.offsetTop, itemImage.offsetTop, grid.offsetParent.offsetTop, initialValue.wrapperMarginTop);
      //console.log(itemImage.style.width);
      //animateClick(e, initialValue);
      //calcEnd(initialValue);
      if (clicked && reverse === false) {
        document.querySelector("html").style.marginLeft = "-" + (scrollbarWidth/2) + "px";
        document.querySelector("html").classList.add("pageAnimating", "loading");

        document.querySelector(".masthead").style.width = `calc(100% + ${(scrollbarWidth/2 + "px")})`;
        document.querySelector(".masthead").style.paddingRight = `${(scrollbarWidth/2 + "px")}`;
        main.style.marginLeft = "-" + (scrollbarWidth/2) + "px";
        body.style.overflowY = "hidden";
        bodyScrollLock.disableBodyScroll(targetElement);
      }
      calcEnd(item, initialValue, clicked, reverse);
};

function calcEnd(item, initialValue, clicked, reverse) {


wipe = item.querySelector(".wipe");
itemImage = item.querySelector(".gridgrow-image");
let gridgrowWidth = item.offsetWidth;
    
    //console.log("RESIZING");
    
    let wipeParent = item.querySelector(".gridgrow-image-holder");
 
    // 4. Useful if we have called disableBodyScroll for multiple target elements,
    // and we just want a kill-switch to undo all that.
    //bodyScrollLock.clearAllBodyScrollLocks();
    let scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
    //console.log("itemImage");
    //console.log(itemImage);
    let gridContainerPadding = parseFloat(getComputedStyle(gridContainer).paddingLeft)+ parseFloat(getComputedStyle(gridContainer).paddingRight);
    let containerPadding = parseFloat(getComputedStyle(container).paddingLeft) + parseFloat(getComputedStyle(container).paddingRight);
    let containerWidth = parseFloat(container.offsetWidth) - containerPadding;
    let translateX, wipeTranslateX;
    if (featured) {
      console.log("left: " + (-initialValue.item.left - initialValue.item.offsetLeft + initialValue.containerOffsetLeft));
      
      translateX = ((-initialValue.item.left - initialValue.item.offsetLeft + initialValue.containerOffsetLeft));
      
      wipeTranslateX = (initialValue.scrollbarWidth/2);

    } else {
      translateX = (-initialValue.item.left - initialValue.gridContainerOffsetLeft) + (initialValue.wrapperMarginLeft - item.offsetLeft) + container.offsetLeft + initialValue.containerPaddingLeft - (initialValue.scrollbarWidth/2);
      wipeTranslateX = -(item.offsetLeft + item.offsetParent.offsetLeft) - initialValue.windowScrollX + initialValue.scrollbarWidth;
    }

    //console.log("containerWidth: " + containerWidth);
// the final velocity values. To reverse animation, 

  let endValue = {
    containerOffsetLeft: container.offsetLeft,
    windowWidth: window.innerWidth,
    windowHeight: window.innerHeight,
    windowScrollX: window.scrollX,
    windowScrollY: window.scrollY,
    scrollbarWidth: parseFloat(scrollbarWidth),
    mobileScrollbar: parseFloat(mobileScrollbar),
    navHeight: document.querySelector(".masthead").offsetHeight,
    gridContainerPadding: parseFloat(getComputedStyle(gridContainer).paddingLeft)+ parseFloat(getComputedStyle(gridContainer).paddingRight),
    containerPadding: parseFloat(getComputedStyle(container).paddingLeft) + parseFloat(getComputedStyle(container).paddingRight),
    containerWidth: parseFloat(container.offsetWidth) - containerPadding,
    wrapperMarginTop: parseFloat(getComputedStyle(wipeParent).marginTop),
    wrapperMarginLeft: -(parseFloat(getComputedStyle(wipeParent).marginLeft)),
    containerPaddingLeft: containerPadding / 2,
    gridContainerPaddingLeft: gridContainerPadding / 2,
    gridContainerOffsetLeft: gridContainer.offsetLeft,
    heightSpacerHeight: heightSpacer.offsetHeight,
    wipe: {
        width: initialValue.windowWidth + initialValue.scrollbarWidth,
        height: (initialValue.windowHeight) + (initialValue.windowWidth * .2),
        translateX: wipeTranslateX,
        translateY: -((item.offsetTop + grid.offsetParent.offsetTop + initialValue.wrapperMarginTop) - initialValue.windowScrollY - initialValue.navHeight),
        left: initialValue.mobileScrollbar,
        top: "0px",
        duration: 500,
        delay: 50,
        easing: "swing",
        z: 888
      },
      item: {
        width: initialValue.item.width * (initialValue.containerWidth / initialValue.item.width),
        height: initialValue.item.height * (initialValue.containerWidth / initialValue.item.width),        
        translateX: translateX,
        translateY: -((item.offsetTop + itemImage.offsetTop + grid.offsetParent.offsetTop + initialValue.wrapperMarginTop) - initialValue.windowScrollY - initialValue.navHeight - initialValue.heightSpacerHeight),
        offsetLeft: wipeParent.offsetLeft,
        left: initialValue.item.left,
        top: "0px",
        duration: 500,
        delay: 50,
        easing: "swing",
        z: 999
      },
      content: {
        top: 0,
        imgTop: initialValue.content.imgTop,
      }
  }
  
  console.log("startValue:");
  console.log(initialValue);
  // console.log("endValue:");
  console.log(endValue);
  console.log("END LEFT: " + endValue);

  if (clicked) {
    animateItem(item, initialValue, endValue, reverse);
  }
  
  if (item.classList.contains("active") && !clicked ) {
    itemImage.style.width = endValue.item.width + "px";
    itemImage.style.height = endValue.item.height + "px";
    itemImage.style.transform = `translateX(${endValue.item.translateX}px) translateY(${endValue.item.translateY}px)`;
  }
}

function animateItem(item, initialValue, endValue, reverse) {
  
  //bodyScrollLock.disableBodyScroll(targetElement);

  //item.removeEventListener("click", animateClick, false);

  // don't want image to trigger click again
  //item.removeEventListener("click", animateClick, false);
  // console.log("ANIMATION ITEM START ---------------------");
  // console.log("initial values:");
  // console.log(initialValue);
  // let windowHeight = initialValue.windowHeight;
  // let windowWidth = initialValue.windowWidth;
  itemImage = item.querySelector(".gridgrow-image");

  //console.log("MATH:")
  //console.log(initialValue.wrapperMarginLeft);
  // console.log("end values:");
  // console.log(endValue);
  // change start values based on if the animation is being reversed

  let startValue;
  if (reverse) {

    startValue = endValue;
    endValue = initialValue;
    item.classList.remove("active");
    itemImage.style.visibility = "visible";
  } else {

    startValue = initialValue;
    endValue = endValue;
    itemImage.style.zIndex = 999;
    wipe.style.zIndex = 888;
    item.style.overflow = "visible";
    item.querySelector(".gridwrap").style.overflow = "visible";
    item.querySelector(".gridgrow-image-holder").style.overflow = "visible";

  }
  // Start ajax loading the content
  ajaxWorkItem(item, initialValue, endValue, reverse);
  // Start animation
  velocityAnimate(item, initialValue, startValue, endValue, reverse);
}
  function velocityAnimate(item, initialValue, startValue, endValue, reverse) {

      wipe.velocity({
        width: [endValue.wipe.width, startValue.wipe.width],
        height: [endValue.wipe.height, startValue.wipe.height],
        transform: [`translateX(${endValue.wipe.translateX}px) translateY(${endValue.wipe.translateY}px)`, `translateX(${startValue.wipe.translateX}px) translateY(${startValue.wipe.translateY}px)`],
        //transform: [endValue.scale, startValue.scale],
        left: [endValue.wipe.left, startValue.wipe.left],
        top: [endValue.wipe.top, startValue.wipe.top],
      }, 
      {
        delay: startValue.wipe.delay,
        duration: startValue.wipe.duration,
        easing: startValue.wipe.easing,
        /* Velocity's default options */
      });

      itemImage
      .velocity({
        transform: [`translateX(${endValue.item.translateX}px) translateY(${endValue.item.translateY}px)`, `translateX(${startValue.item.translateX}px) translateY(${startValue.item.translateY}px)`],
        //left: [`-${itemOffsetLeft}px`, `${itemOffsetLeft}px`],
        //top: [endValue.item.top, startValue.item.top],
        bottom: [endValue.item.bottom, startValue.item.bottom],
        "background-position-y": [endValue.item.backgroundPositionY, startValue.item.backgroundPositionY],
        width: [endValue.item.width, startValue.item.width],
        height: [endValue.item.height, startValue.item.height]
      }, 
      {
        duration: startValue.item.duration,
        delay: startValue.item.delay,
        easing: startValue.item.easing,
        queue: "",
        loop: false,
        mobileHA: true,
        /* Velocity's default options */
        progress: function(elements, complete, remaining, start, tweenValue) {
          //console.log(complete);
          if (complete === 1) {
            //AOS.refresh();
            if (reverse) {
              item.style.overflow = "";
              item.querySelector(".gridwrap").style.overflow = "";
              item.querySelector(".gridgrow-image-holder").style.overflow = "";
              
              //gridImageSize();
              //initialGridState();
              
              document.querySelector("html").style.marginLeft = "";
              document.querySelector("main").style.marginLeft = "";
              document.querySelector(".masthead").style = "";

              document.querySelector("html").classList.remove("pageAnimating", "loading");
              body.style.overflowY = "scroll";
              bodyScrollLock.enableBodyScroll(targetElement);
              //item.addEventListener("click");
              itemImage.style.zIndex = "";
              wipe.style.zIndex = "";
              item.querySelector(".gridgrow-image").velocity({
                visibility: ["visible", "hidden"],
              }, {
                delay: 0,
                duration: 0,
              });
            } else {
              //console.log("item complete: ");
              //console.log(itemImage);
              item.classList.add("active");

              //BEN ADD THIS BACK
              item.querySelector(".gridgrow-image").velocity({
                visibility: ["hidden", "visible"],
              }, {
                delay: 600,
                duration: 100,
                complete: function() {
                  workAjax.style.overflowY = "scroll";
                }
              });
              //itemImage.style.width = endValue.item.width;
              reverseAnimation(item, initialValue, startValue, endValue);
              // window.addEventListener("resize", function(){
              //   itemImage.style.width = endValue.item.width + "px";
              // });
            }
            
          }
        }
      })
    
  }

function setFinalValues(item, initialValue, startValue, endValue) {

  if (item.classList.contains("active")) {
    //console.log("setting final values...");
    itemImage = item.querySelector(".gridgrow-image");
    //console.log(itemImage);
    itemImage.style.width = endValue.item.width;
    itemImage.style.height = endValue.item.height;
  }

}
function reverseAnimation(item, initialValue, startValue, endValue) {
  //window.location.href = window.location.origin;

  // window.addEventListener("resize", function(){
  //   setFinalValues(item, initialValue, startValue, endValue);
  // });

  let reverseBtn = document.createElement("div");
  reverseBtn.classList.add("reverseAnimation");
  reverseBtn.innerHTML = `<span>Close</span><i class="fa fa-window-close" aria-hidden="true"></i>`;

  //reverseBtn.appendChild(t);
  document.body.appendChild(reverseBtn);

  //detect back btn then hijack it
  window.onpopstate = function(event) {
    window.history.pushState("object or string", "Title", pageUrl);
    reverseClick();
  }

  function reverseClick(e) {

    reverse = true;
    windowScrollY = 0;
    let element = document.querySelector(".reverseAnimation");
    element.parentNode.removeChild(element);
    clicked = true;
    //workAjax.scrollTop = 0;
    workAjax.velocity({scrollTop: "0px"}, {
      duration: 300,
      delay: 0,
      complete: function() {
        calcStart(item, initialValue, endValue, reverse, clicked);
        //console.log("REVERSE COMPLETE");
      }
    });
    
    //animateItem(item, initialValue, endValue, reverse, clicked);
    
    //clicky();
  }
  reverseBtn.addEventListener("click", reverseClick, false);     
      
}

function ajaxWorkItem (item, initialValue, endValue, reverse) {

  let pageCritical = document.querySelector(".page_critical_css");
  //console.log(pageCritical);

  if (reverse) {

    //add back logo for animation
    document.querySelector("html").classList.add("loading");

    workAjax
    .velocity({
      opacity: 0,
      visibility: ["hidden", "visible"]
    }, {
      duration: 400,
    })
    .velocity({
      display: "none",
    }, {
      duration: 0,
    });

    workAjax.innerHTML = "";
    
  } else {
    let nextLink = item.querySelector("a").getAttribute("href");
      
    //https://stackoverflow.com/questions/36631762/returning-html-with-fetch
    // AJAX CALL
    
      fetch(nextLink /*, options */)
      .then((response) => response.text())
      .then((html) => {
          let parser = new DOMParser();

          // Parse the text
          var doc = parser.parseFromString(html, "text/html");
          var docArticle = doc.querySelector('main').innerHTML;
          //var pbCritical = doc.querySelector('.pb_criticalCSS').innerHTML;
          workAjax.innerHTML = docArticle;
          //pageCritical.innerHTML = pageCritical.innerHTML + pbCritical;
          //console.log(pageCritical);
          window.history.pushState("object or string", "Title", nextLink);
          // just using this for testing. Need to trigger aos after page content loads. Need the CSS from this page to be called.
          
          //reload scripts that are in innerHTML https://ghinda.net/article/script-tags/
          runScripts(workAjax, nextLink);
          redoAos(workAjax)
              
      })
      .catch((error) => {
          console.warn(error);
      });
      workAjax
      .velocity({
        top: [initialValue.navHeight, 0],
        display: ["block", "none"]
      })
      .velocity({
        opacity: [1, 0],
        visibility: ["visible", "hidden"]
      }, {
        delay: 400,
        duration: 400,
        complete: function() {
        document.querySelector("html").classList.remove("loading");
          //console.log("REVERSE COMPLETE");
        }
      });
      // setTimeout(function(){
      //   AOS.init();
      //   console.log("aos refresh");
      // }, 3000);
      // var scrolling = false;

      // $( window ).scroll( function() {
      //   scrolling = true;
      // });

      // setInterval( function() {
      //   if ( scrolling ) {
      //     scrolling = false;
      //     // Do your thang!
      //   }
      // }, 250 );
  }
  
}

function insertScript (script, callback) {
  console.log(script);
  var s = document.createElement('script')
  s.type = 'text/javascript'
  if (script.src) {
    s.onload = callback
    s.onerror = callback
    s.src = script.src
  } else {
    s.textContent = script.innerText
  }

  // re-insert the script tag so it executes.
  container.appendChild(s)

  // clean-up
  script.parentNode.removeChild(script)

  // run the callback immediately for inline scripts
  if (!script.src) {
    callback()
  }
}
  
// trigger DOMContentLoaded
function scriptsDone () {
  var DOMContentLoadedEvent = document.createEvent('Event')
  DOMContentLoadedEvent.initEvent('DOMContentLoaded', true, true)
  document.dispatchEvent(DOMContentLoadedEvent)
}
  
  // runs an array of async functions in sequential order
function seq (arr, callback, index) {
  // first call, without an index
  if (typeof index === 'undefined') {
    index = 0
  }

  arr[index](function () {
    index++
    if (index === arr.length) {
      callback()
    } else {
      seq(arr, callback, index)
    }
  })
}

// https://html.spec.whatwg.org/multipage/scripting.html
var runScriptTypes = [
  'application/javascript',
  'application/ecmascript',
  'application/x-ecmascript',
  'application/x-javascript',
  'text/ecmascript',
  'text/javascript',
  'text/javascript1.0',
  'text/javascript1.1',
  'text/javascript1.2',
  'text/javascript1.3',
  'text/javascript1.4',
  'text/javascript1.5',
  'text/jscript',
  'text/livescript',
  'text/x-ecmascript',
  'text/x-javascript'
]

function runScripts (container, nextLink) {
  //console.log(container);
  //console.log("run SCRIPTS ---");
  // get scripts tags from a node
  var scripts = container.querySelectorAll('script');
  var images = container.querySelectorAll('img');
  var runList = [];
  var typeAttr;

    images.forEach(image => {
      
      //image.src = nextLink + image.src;
      let path = image.getAttribute("src");

      if (!new RegExp("^(?:/|.+://)").test(path)) {
        //console.log(path);
        path = nextLink + path;
        image.setAttribute("src", path);
      }
    });

    [].forEach.call(scripts, function (script) {
      //console.log(script);
    typeAttr = script.getAttribute('type');
    // only run script tags without the type attribute
    // or with a javascript mime attribute value
    if (!typeAttr || runScriptTypes.indexOf(typeAttr) !== -1) {
      runList.push(function (callback) {
        
        insertScript(script, callback)
      })
    }
  })

  // insert the script tags sequentially
  // to preserve execution order
  seq(runList, scriptsDone);


  

  
}

function redoAos(container) {
  console.log("redoaos");
  console.log(container);
// Find the item we want to animate on scroll
let target = container.querySelector('[data-aos]');

var targetActiveClass = 'aos-animate';
let elements = container.querySelectorAll('[data-aos]');
// Call this function when it enters/leaves the viewport
var callback = function(entries, observer) { 
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      entry.target.classList.add(targetActiveClass);
    } else {
      entry.target.classList.remove(targetActiveClass);
    }
  });
};

// Create our observer
var observer = new IntersectionObserver(callback, {threshold: 0});
  elements.forEach(element => {
    observer.observe(element);
  });
}


}




</script>