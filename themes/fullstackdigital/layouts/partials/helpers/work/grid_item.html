{{ $size := .page.grid.columns | default "4" }}

<div class="work-grid-tabs container flex h_children_space-between">
  <div class="col-4 flex h_children_space-between">
      <svg class="padding-xs-bottom" id="Layer_1" width="44" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
        <title>Services</title>
        <g>
        <rect x="1" y="18" fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" width="62" height="36"></rect>
        </g>
        <line fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" x1="1" y1="30" x2="63" y2="30"></line>
        <polyline fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" points="27,30 27,36 37,36 37,30 "></polyline>
        <path fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" d="M23,18c0,0,0-8,9-8s9,8,9,8"></path>
        </svg>
        <svg class="padding-xs-bottom" id="Layer_1" width="44" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
          <title>Services</title>
          <g>
          <rect x="1" y="18" fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" width="62" height="36"></rect>
          </g>
          <line fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" x1="1" y1="30" x2="63" y2="30"></line>
          <polyline fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" points="27,30 27,36 37,36 37,30 "></polyline>
          <path fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" d="M23,18c0,0,0-8,9-8s9,8,9,8"></path>
          </svg>
          <svg class="padding-xs-bottom" id="Layer_1" width="44" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
            <title>Services</title>
            <g>
            <rect x="1" y="18" fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" width="62" height="36"></rect>
            </g>
            <line fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" x1="1" y1="30" x2="63" y2="30"></line>
            <polyline fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" points="27,30 27,36 37,36 37,30 "></polyline>
            <path fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" d="M23,18c0,0,0-8,9-8s9,8,9,8"></path>
          </svg>
  </div>
  
</div>
<div class="container" id="loading_content" style="visibility: visible; display: block;">
<div class="masonry-container work-grid row-{{ $size }}">
<!-- <div class="gutter-guide"></div> -->

{{ range (where $.global.Site.RegularPages "Section" "work") }}

<!--way too much effort to grab the client logo for the grid item-->
{{ $prefix := "assets/images/clients/" }}
{{ $asset_prefix := "images/clients/" }}
{{ $context := .Params.stacks_hero }}
{{ $image := .Resources.GetMatch $context.image }}
{{ $logo := "" }}
{{ $name := $context.client }}
  {{ if or (eq .Params.grid_item.logo_color "color") (eq .Params.grid_item.logo_color true ) }}
    {{ $prefix = "assets/images/clients/color/" }}
    {{ $asset_prefix = "images/clients/color/" }}
  {{ else if or (eq .Params.grid_item.logo_color "white") (eq .Params.grid_item.logo_color false ) }}
    {{ $prefix = "assets/images/clients/white/" }}
    {{ $asset_prefix = "images/clients/white/" }}
  {{ else if or (eq .Params.grid_item.logo_color "black") }}
    {{ $prefix = "assets/images/clients/black/" }}
    {{ $asset_prefix = "images/clients/black/" }}
  {{ end }}
  
{{ range $.global.Site.Data.lookup.clients }}
  {{ if eq .name $name }}
    {{ $logo = .image }}
  {{ end }}
{{ end }}

{{ $path := print $prefix $logo }}
{{ $assetpath := print $asset_prefix $logo }}
<div class='gridgrow '>
  <a class="work-link gridgrow-link" href='{{ .URL }}' title=""><span>{{ .Title | safeHTML }}</span></a>
  <div class="gridwrap background-light">

    <div class="flex-center gridgrow-image-holder" style="background-color: {{ .Params.stacks_hero.background_color | safeHTML }};">


      {{/* <div class="gridgrow-image lazyload lazypreload" data-bg=''></div> */}}
      <img class="gridgrow-image" calc-size='' data-src='{{ $image.Permalink }}'>

      <div style="background-color: {{ .Params.stacks_hero.background_color | safeHTML }};" class="wipe">
      </div>
    </div>

  <div class="card-footer" itemprop="description">
  <div class="excerpt-group">
  <div class="card-logo-holder flex-center-vertical">
  {{ if (fileExists $path) }}
  {{ $imagesrc := resources.Get $assetpath }}
  <img class="card-logo" src="{{ $imagesrc.Permalink }}">
  {{ end }}
  </div>
  <h6 class="gridgrow-excerpt strip-margin">{{ .Title | safeHTML }}</h6>
    <span class="card-footer-layer flex h_children_center hover-right">
      <h6 class="gridgrow-view strip-margin">View Case Study</h6>
      <svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="32px" height="32px" viewBox="0 0 64 64" enable-background="new 0 0 64 64" xml:space="preserve">
      <g>
      <line fill="none" stroke-width="2" stroke-miterlimit="10" x1="0" y1="32" x2="63" y2="32"></line>
      </g>
      <polyline fill="none" stroke-width="2" stroke-linejoin="bevel" stroke-miterlimit="10" points="54,41 63,32 
                        54,23 "></polyline>
      </svg>
    </span>
  </div>
  
  </div>
  </div>
</div>

{{ end }}
</div>

</div>
<div class="container-m spacer"></div>
<div class="height-spacer"><div id="project-summary" class="container padding-m-top padding-m-bottom flex h_children_space-between break-t"><div class="col-3 t-col-8 grid"><img class="client_logo lazypreload lazyloaded" src=""><div class="flex tiny color-oil padding-s-top strip-padding-tablet h_children_space-between"><ul><li class="active">Brand</li><li class="active">Development</li><li class="active">Identity</li><li>Strategy</li></ul><ul><li>Web</li><li>Experience</li><li>Design</li><li>Development</li></ul><ul><li>Market</li><li>Search</li><li>Content</li><li>Social</li></ul></div></div><div class="col-8 flex v_c-center maxwidth-s t-col-12"><h1 class="page-title strip-margin-bottom color-oil"></h1></div></div></div>
<div class="work-ajax"></div>

{{ $velocity := resources.Get "js/plugins/velocity.min.js" | minify }}
{{ $scroll_lock := resources.Get "js/plugins/bodyScrollLock.js" | minify }}

<script type="text/javascript" src="{{ $velocity.Permalink }}"></script>
<script type="text/javascript" src="{{ $scroll_lock.Permalink }}"></script>
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/barba.js/1.0.0/barba.min.js"></script> -->
<script type="text/javascript">

document.addEventListener("DOMContentLoaded", function(){
  //console.log(ajaxRequest);
  ajaxGrid();
  
});


function ajaxGrid(){
console.log("DOMContentLoaded... Starting Ajax Grid");

// get all of the selectors we are working with.
let gridItems = document.querySelectorAll(".gridgrow");
let gridImages = document.querySelectorAll(".gridgrow-image");
let workAjax = document.querySelector(".work-ajax");
let heightSpacer = document.querySelector(".height-spacer");
let gridLinks = document.querySelectorAll(".gridgrow a");
let body = document.querySelector("body");
let gridContainer = document.querySelector(".container");
let container = document.querySelector(".container-m.spacer");
let grid = document.querySelector(".work-grid");
let scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
let mobileScrollbar;

if (scrollbarWidth === 0) {
  console.log("no scrollbarwidth");
  mobileScrollbar = 20;
} else {
  mobileScrollbar = 0;
}
const targetElement = document.querySelector("body");

gridImageSize();

function gridImageSize(){

// FIX THIS BEHAVIOR: 
// If grid image is expanded and window resized, the expanded image resizes. The initial values should resize, but not the currently active image.

let gridgrowWidth;
//BEN NOTE:
// get count of all images
// compare the count of all images to images loaded
// run the next function when all loaded
// just show loading indicator for the page untill the items finish.

//console.log(gridImageCount);
//console.log("count of images: " + gridImages.length);
gridImages.forEach(function(image, imageLoaded = 0) {
  // console.log(image);
  // console.log("loaded " + image);
  image.addEventListener('load', () => {
    // if (image.classList.contains("lazyloaded")) {
      //console.log(image);
      imageLoaded++;
      let item = image.parentElement.parentElement.parentElement;
      let link = item.querySelector("a");
      item.classList.add("loaded");

      // resize the image as it loads
      //setImageSize(image, item);
      //console.log("resizing");
      //animateGrid();
      clicked = false;
      reverse = false;
      calcStart(item, clicked, reverse);

      if ( imageLoaded === gridImages.length ) {
        //console.log("----- All Images Loaded Image Loaded.... run animate grid ");
        //console.log(imageLoaded);
        // Grid can be animated now since all initial values are set
        //animateGrid();
      } else {
        //console.log(`Not all images loaded yet -----${gridImages.length - imageLoaded} left to load.`);
      }
    // }
    window.addEventListener("resize", function(){
    //console.log(ajaxRequest);
      setImageSize(image, item);
      //console.log("resizing");
      //animateGrid();
      clicked = false;
      reverse = false;
      calcStart(item, clicked, reverse);

      
    });

    window.addEventListener("scroll", function(){
       itemViewport(item);
    });
    
    function heightSpacerContent(item){
      let logoImage = item.querySelector(".card-logo");
      let spacerLogo = heightSpacer.querySelector(".client_logo");
      let itemExcerpt = item.querySelector(".gridgrow-excerpt");
      let spacerTitle = heightSpacer.querySelector(".page-title");
      spacerLogo.src = logoImage.src;
      spacerTitle.innerText = itemExcerpt.innerText;
    }
    
    function itemViewport(item){
      var isInViewport = function (elem) {
      var bounding = elem.getBoundingClientRect();
      return (
          bounding.top >= 0 &&
          bounding.left >= 0 &&
          bounding.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
          bounding.right <= (window.innerWidth || document.documentElement.clientWidth)
          );
      };

      if (isInViewport(item)) {
          // Do something...
          //console.log("in viewport");
          //console.log(item);
          heightSpacerContent(item);
      }
    }

    item.addEventListener("click", function(e){
    //console.log(ajaxRequest);
    item = e.currentTarget;
    
    heightSpacerContent(item);
    //console.log("clicked");
    e.preventDefault();
    

    clicked = true;
    reverse = false;
      calcStart(item, clicked, reverse);
      //animateClick(item, initialValue);
    });
  });

  
});
}

function setImageSize (image, item) {
  // console.log("setimagesize");
  // let imageWrapper = image.parentNode;
  // let wrapperMargin = parseFloat(getComputedStyle(imageWrapper).marginTop);
  // let ratio = image.naturalHeight / imageWrapper.offsetHeight;
  // let imageHeight = (image.naturalHeight / ratio) * .7;
  // let imageWidth = (image.naturalWidth / ratio) * .7;

  // if (!item.classList.contains("active")) {
  //   image.style.height = imageHeight + "px";
  //   image.style.width = imageWidth + "px";

  //   //console.log(gridgrowWidth);
  //   image.style.top = (imageWrapper.offsetHeight - wrapperMargin - imageHeight) / 2 + "px";
  //   image.style.left = (imageWrapper.offsetWidth - imageWidth) / 2 + "px";
  //   //console.log("height: " + imageHeight);
  // }
  
  
}

//animateItem();

let pageUrl = window.location;

function calcStart(item, clicked, reverse) {

    
    //console.log("setimagesize");
    let image = item.querySelector(".gridgrow-image");
    let imageWrapper = image.parentNode;
    let wrapperMargin = parseFloat(getComputedStyle(imageWrapper).marginTop);
    let ratio = image.naturalHeight / imageWrapper.offsetHeight;
    let imageHeight = (image.naturalHeight / ratio) * .7;
    let imageWidth = (image.naturalWidth / ratio) * .7;


    if (!item.classList.contains("active")) {
      image.style.height = imageHeight + "px";
      image.style.width = imageWidth + "px";

      //console.log(gridgrowWidth);
      image.style.top = (imageWrapper.offsetHeight - wrapperMargin - imageHeight) / 2 + "px";
      image.style.left = (imageWrapper.offsetWidth - imageWidth) / 2 + "px";
      //console.log("height: " + imageHeight);
    }
//console.log("calcstart");
//console.log(item);
    // I need to grab some starting values ON CLICK
    // Needs to be on click because some positions are based on the scroll offset
    let gridgrowWidth = item.offsetWidth;
    
    //console.log("RESIZING");
    let wipe = item.querySelector(".wipe");
    let wipeParent = item.querySelector(".gridgrow-image-holder");
    let itemImage = item.querySelector(".gridgrow-image");
    let body = document.querySelector("body");
    let main = document.querySelector("main");
    // 4. Useful if we have called disableBodyScroll for multiple target elements,
    // and we just want a kill-switch to undo all that.
    //bodyScrollLock.clearAllBodyScrollLocks();
    
    //console.log("itemImage");
    //console.log(itemImage);
    let gridContainerPadding = parseFloat(getComputedStyle(gridContainer).paddingLeft)+ parseFloat(getComputedStyle(gridContainer).paddingRight);
    let containerPadding = parseFloat(getComputedStyle(container).paddingLeft) + parseFloat(getComputedStyle(container).paddingRight);
    let containerWidth = parseFloat(container.offsetWidth) - containerPadding;
    //console.log("containerWidth: " + containerWidth);
    
    let imgTop = 355;

    let navHeight = document.querySelector(".masthead").offsetHeight;
    let initialValue = {
        containerOffsetLeft: container.offsetLeft - (scrollbarWidth/2),
        windowWidth: window.innerWidth,
        windowHeight: window.innerHeight,
        windowScrollX: window.scrollX,
        windowScrollY: window.scrollY,
        scrollbarWidth: scrollbarWidth,
        mobileScrollbar: parseFloat(mobileScrollbar),
        navHeight: document.querySelector(".masthead").offsetHeight,
        gridContainerPadding: parseFloat(getComputedStyle(gridContainer).paddingLeft)+ parseFloat(getComputedStyle(gridContainer).paddingRight),
        containerPadding: parseFloat(getComputedStyle(container).paddingLeft) + parseFloat(getComputedStyle(container).paddingRight),
        containerWidth: parseFloat(container.offsetWidth) - containerPadding,
        wrapperMarginTop: parseFloat(getComputedStyle(wipeParent).marginTop),
        wrapperMarginLeft: -(parseFloat(getComputedStyle(wipeParent).marginLeft)),
        containerPaddingLeft: containerPadding / 2,
        gridContainerPaddingLeft: gridContainerPadding / 2,
        gridContainerOffsetLeft: gridContainer.offsetLeft,
        heightSpacerHeight: heightSpacer.offsetHeight,
        wipe: {
          width: wipeParent.offsetWidth,
          height: wipeParent.offsetHeight,
          translateX: "0px",
          translateY: "0px",
          left: "0.1px",
          top: "0.1px",
          duration: 100,
          delay: 0,
          easing: "swing",
          z: wipe.style.zIndex,
        },
        item: {
          width: imageWidth,
          height: imageHeight,
          translateX: "0px",
          translateY: "0px",
          left: parseFloat(itemImage.style.left),
          top: itemImage.offsetTop,
          backgroundPositionY: "60%",
          duration: 400,
          delay: 50,
          easing: "swing",
          z: itemImage.style.zIndex,
        },
        content: {
          top: 0,
          imgTop: imgTop,
        }
      }
        
      //console.log("START OFFSET LEFT:");
      //console.log(initialValue);
      //console.log(initialValue.mobileScrollbar, item.offsetTop, itemImage.offsetTop, grid.offsetParent.offsetTop, initialValue.wrapperMarginTop);
      //console.log(itemImage.style.width);
      //animateClick(e, initialValue);
      //calcEnd(initialValue);
      if (clicked && reverse === false) {
        document.querySelector("html").style.marginLeft = "-" + (scrollbarWidth/2) + "px";
        main.style.marginLeft = "-" + (scrollbarWidth/2) + "px";
        body.style.overflowY = "hidden";
        bodyScrollLock.disableBodyScroll(targetElement);
      }
      calcEnd(item, initialValue, clicked, reverse);
};

function calcEnd(item, initialValue, clicked, reverse) {


wipe = item.querySelector(".wipe");
itemImage = item.querySelector(".gridgrow-image");
let gridgrowWidth = item.offsetWidth;
    
    //console.log("RESIZING");
    
    let wipeParent = item.querySelector(".gridgrow-image-holder");
 
    // 4. Useful if we have called disableBodyScroll for multiple target elements,
    // and we just want a kill-switch to undo all that.
    //bodyScrollLock.clearAllBodyScrollLocks();
    let scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
    //console.log("itemImage");
    //console.log(itemImage);
    let gridContainerPadding = parseFloat(getComputedStyle(gridContainer).paddingLeft)+ parseFloat(getComputedStyle(gridContainer).paddingRight);
    let containerPadding = parseFloat(getComputedStyle(container).paddingLeft) + parseFloat(getComputedStyle(container).paddingRight);
    let containerWidth = parseFloat(container.offsetWidth) - containerPadding;
    //console.log("containerWidth: " + containerWidth);
// the final velocity values. To reverse animation, 

  let endValue = {
    containerOffsetLeft: container.offsetLeft - (scrollbarWidth/2),
    windowWidth: window.innerWidth,
    windowHeight: window.innerHeight,
    windowScrollX: window.scrollX,
    windowScrollY: window.scrollY,
    scrollbarWidth: parseFloat(scrollbarWidth),
    mobileScrollbar: parseFloat(mobileScrollbar),
    navHeight: document.querySelector(".masthead").offsetHeight,
    gridContainerPadding: parseFloat(getComputedStyle(gridContainer).paddingLeft)+ parseFloat(getComputedStyle(gridContainer).paddingRight),
    containerPadding: parseFloat(getComputedStyle(container).paddingLeft) + parseFloat(getComputedStyle(container).paddingRight),
    containerWidth: parseFloat(container.offsetWidth) - containerPadding,
    wrapperMarginTop: parseFloat(getComputedStyle(wipeParent).marginTop),
    wrapperMarginLeft: -(parseFloat(getComputedStyle(wipeParent).marginLeft)),
    containerPaddingLeft: containerPadding / 2,
    gridContainerPaddingLeft: gridContainerPadding / 2,
    gridContainerOffsetLeft: gridContainer.offsetLeft,
    heightSpacerHeight: heightSpacer.offsetHeight,
    wipe: {
        width: initialValue.windowWidth + initialValue.scrollbarWidth,
        height: (initialValue.windowHeight) + (initialValue.windowWidth * .2),
        translateX: -(item.offsetLeft + item.offsetParent.offsetLeft) - initialValue.windowScrollX + initialValue.scrollbarWidth,
        translateY: -((item.offsetTop + grid.offsetParent.offsetTop + initialValue.wrapperMarginTop) - initialValue.windowScrollY - initialValue.navHeight),
        left: initialValue.mobileScrollbar,
        top: "0px",
        duration: 500,
        delay: 50,
        easing: "swing",
        z: 888
      },
      item: {
        width: initialValue.item.width * (initialValue.containerWidth / initialValue.item.width),
        height: initialValue.item.height * (initialValue.containerWidth / initialValue.item.width),
        // itemLeft = -125.587
        // gridContainerPadding = +1
        // container offsetleft = +107
        
        // container paddingLeft = 20
        
        // 
        // -102 + 107 = 5 - (20 -21.78 - 20)
        
        translateX: (-initialValue.item.left - initialValue.gridContainerOffsetLeft) + (initialValue.wrapperMarginLeft - item.offsetLeft) + container.offsetLeft + initialValue.containerPaddingLeft - (initialValue.scrollbarWidth/2),
        // translateY: -((item.offsetTop + itemImage.offsetTop + grid.offsetParent.offsetTop + initialValue.wrapperMarginTop ) - initialValue.windowScrollY - navHeight),
        translateY: -((item.offsetTop + itemImage.offsetTop + grid.offsetParent.offsetTop + initialValue.wrapperMarginTop) - initialValue.windowScrollY - initialValue.navHeight - initialValue.heightSpacerHeight),
        top: "0px",
        duration: 500,
        delay: 50,
        easing: "swing",
        z: 999
      },
      content: {
        top: 0,
        imgTop: initialValue.content.imgTop,
      }
  }
  
  // console.log("startValue:");
  // console.log(initialValue);
  // console.log("endValue:");
  // console.log(endValue);
  // console.log("END LEFT: " + endValue.containerOffsetLeft);

  if (clicked) {
    animateItem(item, initialValue, endValue, reverse);
  }
  
  if (item.classList.contains("active") && !clicked ) {
    itemImage.style.width = endValue.item.width + "px";
    itemImage.style.height = endValue.item.height + "px";
    itemImage.style.transform = `translateX(${endValue.item.translateX}px) translateY(${endValue.item.translateY}px)`;
  }
}

function animateItem(item, initialValue, endValue, reverse) {
  
  //bodyScrollLock.disableBodyScroll(targetElement);

  //item.removeEventListener("click", animateClick, false);

  // don't want image to trigger click again
  //item.removeEventListener("click", animateClick, false);
  // console.log("ANIMATION ITEM START ---------------------");
  // console.log("initial values:");
  // console.log(initialValue);
  // let windowHeight = initialValue.windowHeight;
  // let windowWidth = initialValue.windowWidth;
  itemImage = item.querySelector(".gridgrow-image");

  //console.log("MATH:")
  //console.log(initialValue.wrapperMarginLeft);
  // console.log("end values:");
  // console.log(endValue);
  // change start values based on if the animation is being reversed

  let startValue;
  if (reverse) {

    startValue = endValue;
    endValue = initialValue;
    item.classList.remove("active");
    itemImage.style.visibility = "visible";
  } else {

    startValue = initialValue;
    endValue = endValue;
    itemImage.style.zIndex = 999;
    wipe.style.zIndex = 888;
    item.style.overflow = "visible";
    item.querySelector(".gridwrap").style.overflow = "visible";
    item.querySelector(".gridgrow-image-holder").style.overflow = "visible";

  }
  // Start ajax loading the content
  ajaxWorkItem(item, initialValue, endValue, reverse);
  // Start animation
  velocityAnimate(item, initialValue, startValue, endValue, reverse);
}
  function velocityAnimate(item, initialValue, startValue, endValue, reverse) {

      wipe.velocity({
        width: [endValue.wipe.width, startValue.wipe.width],
        height: [endValue.wipe.height, startValue.wipe.height],
        transform: [`translateX(${endValue.wipe.translateX}px) translateY(${endValue.wipe.translateY}px)`, `translateX(${startValue.wipe.translateX}px) translateY(${startValue.wipe.translateY}px)`],
        //transform: [endValue.scale, startValue.scale],
        left: [endValue.wipe.left, startValue.wipe.left],
        top: [endValue.wipe.top, startValue.wipe.top],
      }, 
      {
        delay: startValue.wipe.delay,
        duration: startValue.wipe.duration,
        easing: startValue.wipe.easing,
        /* Velocity's default options */
      });

      itemImage
      .velocity({
        transform: [`translateX(${endValue.item.translateX}px) translateY(${endValue.item.translateY}px)`, `translateX(${startValue.item.translateX}px) translateY(${startValue.item.translateY}px)`],
        //left: [`-${itemOffsetLeft}px`, `${itemOffsetLeft}px`],
        //top: [endValue.item.top, startValue.item.top],
        bottom: [endValue.item.bottom, startValue.item.bottom],
        "background-position-y": [endValue.item.backgroundPositionY, startValue.item.backgroundPositionY],
        width: [endValue.item.width, startValue.item.width],
        height: [endValue.item.height, startValue.item.height]
      }, 
      {
        duration: startValue.item.duration,
        delay: startValue.item.delay,
        easing: startValue.item.easing,
        queue: "",
        loop: false,
        mobileHA: true,
        /* Velocity's default options */
        progress: function(elements, complete, remaining, start, tweenValue) {
          //console.log(complete);
          if (complete === 1) {
            //AOS.refresh();
            if (reverse) {
              item.style.overflow = "";
              item.querySelector(".gridwrap").style.overflow = "";
              item.querySelector(".gridgrow-image-holder").style.overflow = "";
              
              //gridImageSize();
              //initialGridState();
              
              document.querySelector("html").style.marginLeft = "";
              document.querySelector("main").style.marginLeft = "";
              body.style.overflowY = "scroll";
              bodyScrollLock.enableBodyScroll(targetElement);
              //item.addEventListener("click");
              itemImage.style.zIndex = "";
              wipe.style.zIndex = "";
              item.querySelector(".gridgrow-image").velocity({
                visibility: ["visible", "hidden"],
              }, {
                delay: 0,
                duration: 0,
              });
            } else {
              //console.log("item complete: ");
              //console.log(itemImage);
              item.classList.add("active");

              //BEN ADD THIS BACK
              // item.querySelector(".gridgrow-image").velocity({
              //   visibility: ["hidden", "visible"],
              // }, {
              //   delay: 600,
              //   duration: 100,
              // });
              //itemImage.style.width = endValue.item.width;
              reverseAnimation(item, initialValue, startValue, endValue);
              // window.addEventListener("resize", function(){
              //   itemImage.style.width = endValue.item.width + "px";
              // });
            }
            
          }
        }
      })
    
  }

function setFinalValues(item, initialValue, startValue, endValue) {

  if (item.classList.contains("active")) {
    //console.log("setting final values...");
    itemImage = item.querySelector(".gridgrow-image");
    //console.log(itemImage);
    itemImage.style.width = endValue.item.width;
    itemImage.style.height = endValue.item.height;
  }

}
function reverseAnimation(item, initialValue, startValue, endValue) {
  //window.location.href = window.location.origin;

  window.addEventListener("resize", function(){
    setFinalValues(item, initialValue, startValue, endValue);
  });

  let reverseBtn = document.createElement("div");
  reverseBtn.classList.add("reverseAnimation");
  reverseBtn.innerHTML = `<span>Close</span><i class="fa fa-window-close" aria-hidden="true"></i>`;

  //reverseBtn.appendChild(t);
  document.body.appendChild(reverseBtn);

  //detect back btn then hijack it
  window.onpopstate = function(event) {
    window.history.pushState("object or string", "Title", pageUrl);
    reverseClick();
  }

  function reverseClick(e) {

    reverse = true;
    windowScrollY = 0;
    let element = document.querySelector(".reverseAnimation");
    element.parentNode.removeChild(element);

    workAjax.scrollTop = 0;
    // workAjax
    // .velocity("scroll", { 
    //   offset: 0,
    //   axis: "y"
    //   });
    clicked = true;
    //animateItem(item, initialValue, endValue, reverse, clicked);
    calcStart(item, initialValue, endValue, reverse, clicked);
    //clicky();
  }
  reverseBtn.addEventListener("click", reverseClick, false);     
      
}

function ajaxWorkItem (item, initialValue, endValue, reverse) {

  let pageCritical = document.querySelector(".page_critical_css");
  //console.log(pageCritical);

  if (reverse) {
    
    workAjax
    .velocity({
      opacity: 0,
      visibility: ["hidden", "visible"]
    }, {
      duration: 400,
    })
    .velocity({
      display: "none",
    }, {
      duration: 0,
    });

    //workAjax.innerHTML = "";
    
  } else {
    let nextLink = item.querySelector("a").getAttribute("href");
      
    //https://stackoverflow.com/questions/36631762/returning-html-with-fetch
    // AJAX CALL
    
      fetch(nextLink /*, options */)
      .then((response) => response.text())
      .then((html) => {
          let parser = new DOMParser();

          // Parse the text
          var doc = parser.parseFromString(html, "text/html");
          var docArticle = doc.querySelector('main').innerHTML;
          //var pbCritical = doc.querySelector('.pb_criticalCSS').innerHTML;
          workAjax.innerHTML = docArticle;
          //pageCritical.innerHTML = pageCritical.innerHTML + pbCritical;
          console.log(pageCritical);
          window.history.pushState("object or string", "Title", nextLink);
          // just using this for testing. Need to trigger aos after page content loads. Need the CSS from this page to be called.
          
          //reload scripts that are in innerHTML https://ghinda.net/article/script-tags/
              
      })
      .catch((error) => {
          console.warn(error);
      });
      workAjax
      .velocity({
        top: [initialValue.navHeight, 0],
        display: ["block", "none"]
      })
      .velocity({
        opacity: [1, 0],
        visibility: ["visible", "hidden"]
      }, {
        delay: 400,
        duration: 400,
      });
      // setTimeout(function(){
      //   AOS.init();
      //   console.log("aos refresh");
      // }, 3000);
      // var scrolling = false;

      // $( window ).scroll( function() {
      //   scrolling = true;
      // });

      // setInterval( function() {
      //   if ( scrolling ) {
      //     scrolling = false;
      //     // Do your thang!
      //   }
      // }, 250 );
  }
  
}

}




</script>