{{ $size := .page.grid.columns | default "4" }}

<div class="work-grid-tabs container flex h_children_space-between">
  <div class="col-4 flex h_children_space-between">
      <svg class="padding-xs-bottom" id="Layer_1" width="44" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
        <title>Services</title>
        <g>
        <rect x="1" y="18" fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" width="62" height="36"></rect>
        </g>
        <line fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" x1="1" y1="30" x2="63" y2="30"></line>
        <polyline fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" points="27,30 27,36 37,36 37,30 "></polyline>
        <path fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" d="M23,18c0,0,0-8,9-8s9,8,9,8"></path>
        </svg>
        <svg class="padding-xs-bottom" id="Layer_1" width="44" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
          <title>Services</title>
          <g>
          <rect x="1" y="18" fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" width="62" height="36"></rect>
          </g>
          <line fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" x1="1" y1="30" x2="63" y2="30"></line>
          <polyline fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" points="27,30 27,36 37,36 37,30 "></polyline>
          <path fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" d="M23,18c0,0,0-8,9-8s9,8,9,8"></path>
          </svg>
          <svg class="padding-xs-bottom" id="Layer_1" width="44" data-name="Layer 1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
            <title>Services</title>
            <g>
            <rect x="1" y="18" fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" width="62" height="36"></rect>
            </g>
            <line fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" x1="1" y1="30" x2="63" y2="30"></line>
            <polyline fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" points="27,30 27,36 37,36 37,30 "></polyline>
            <path fill="none" stroke="#000000" stroke-width="2" stroke-miterlimit="10" d="M23,18c0,0,0-8,9-8s9,8,9,8"></path>
          </svg>
  </div>
  
</div>
<div class="container" id="loading_content" style="visibility: visible; display: block;">
<div class="masonry-container work-grid row-{{ $size }}">
<!-- <div class="gutter-guide"></div> -->

{{ $total := len .page.grid.items }}
{{ range $index, $grid_items := .page.grid.items }}
{{ $name := .name }}
{{ $order := $index }}

{{ range $index, $item := $.global.Site.Data.placeholder.work }}

{{ if eq .name $name }}
{{ $logo_src := .logo | default "/images/clients/color/quantum.svg" }}
{{ $logo := resources.Get $logo_src }}
{{ $thumb_src := .thumbnail | default "/images/placeholder/ddn-cover.png" }}
{{ $thumb := resources.Get $thumb_src }}

<div class='{{ with .tags }}{{ delimit . " " }}{{ end }} gridgrow'>
  <a class="work-link gridgrow-link" href='{{ .link | default "x" }}' title="{{ .title | safeHTML }}"><span>{{ .title | safeHTML }}</span></a>
  <div class="gridwrap background-night">

    <div class="flex-center gridgrow-image-holder" style="background-color: {{ .background }};">


      {{/* <div class="gridgrow-image lazyload lazypreload" data-bg='{{ $thumb.Permalink }}' style='background-position-y: 60%;'></div> */}}
      <img class="gridgrow-image" calc-size='{{ $thumb.Permalink }}' data-src='{{ $thumb.Permalink }}' style='background-position-y: 60%;'>

      <div style="background-color: {{ .background }};" class="wipe">
      </div>
    </div>

  <div class="card-footer background-night color-white" itemprop="description">
  <div class="excerpt-group">
  <div class="card-logo-holder flex-center-vertical">
  <img class="card-logo" src="{{ $logo.Permalink }}">
  </div>
  <h6 class="gridgrow-excerpt strip-margin">{{ .title | safeHTML }}</h6>
    <span class="card-footer-layer flex h_children_center hover-right">
      <h6 class="gridgrow-view strip-margin">View Case Study</h6>
      <svg class="color-white" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="32px" height="32px" viewBox="0 0 64 64" enable-background="new 0 0 64 64" xml:space="preserve">
      <g>
      <line fill="none" stroke="#ffffff" stroke-width="2" stroke-miterlimit="10" x1="0" y1="32" x2="63" y2="32"></line>
      </g>
      <polyline fill="none" stroke="#ffffff" stroke-width="2" stroke-linejoin="bevel" stroke-miterlimit="10" points="54,41 63,32 
                        54,23 "></polyline>
      </svg>
    </span>
  </div>
  
  </div>
  </div>
</div>
{{ end }}
{{ end }}
{{ end }}

</div>
<div class="container-m spacer"></div>
</div>
<div class="work-ajax"></div>

{{ $velocity := resources.Get "js/plugins/velocity.min.js" | minify }}
{{ $scroll_lock := resources.Get "js/plugins/bodyScrollLock.js" | minify }}

<script type="text/javascript" src="{{ $velocity.Permalink }}"></script>
<script type="text/javascript" src="{{ $scroll_lock.Permalink }}"></script>
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/barba.js/1.0.0/barba.min.js"></script> -->
<script type="text/javascript">

document.addEventListener("DOMContentLoaded", function(){
  //console.log(ajaxRequest);
  ajaxGrid();
  
});


function ajaxGrid(){
console.log("DOMContentLoaded... Starting Ajax Grid");

// get all of the selectors we are working with.
let gridItems = document.querySelectorAll(".gridgrow");
let gridImages = document.querySelectorAll(".gridgrow-image");
const targetElement = document.querySelector("#barba-wrapper");
let workAjax = document.querySelector(".work-ajax");
let gridLinks = document.querySelectorAll(".gridgrow a");
const body = document.querySelector("body");
const gridContainer = document.querySelector(".container");
const container = document.querySelector(".container-m.spacer");
const grid = document.querySelector(".work-grid");

gridImageSize();

function gridImageSize(){

// FIX THIS BEHAVIOR: 
// If grid image is expanded and window resized, the expanded image resizes. The initial values should resize, but not the currently active image.

let gridgrowWidth;
//BEN NOTE:
// get count of all images
// compare the count of all images to images loaded
// run the next function when all loaded
// just show loading indicator for the page untill the items finish.

//console.log(gridImageCount);
//console.log("count of images: " + gridImages.length);
gridImages.forEach(function(image, imageLoaded = 0) {
  // console.log(image);
  // console.log("loaded " + image);
  image.addEventListener('load', () => {
    // if (image.classList.contains("lazyloaded")) {
      console.log(image);
      imageLoaded++;
      let item = image.parentElement.parentElement.parentElement;
      let link = item.querySelector("a");
      item.classList.add("loaded");

      // resize the image as it loads
      setImageSize(image);

      if ( imageLoaded === gridImages.length ) {
        console.log("----- All Images Loaded Image Loaded.... run animate grid ");
        //console.log(imageLoaded);
        // Grid can be animated now since all initial values are set
        //animateGrid();
      } else {
        console.log(`Not all images loaded yet -----${gridImages.length - imageLoaded} left to load.`);
      }
    // }
    window.addEventListener("resize", function(){
    //console.log(ajaxRequest);
      setImageSize(image);
      console.log("resizing");
      //animateGrid();
      calcStart(item);
      
    });
    item.addEventListener("click", function(e){
    //console.log(ajaxRequest);
    item = e.currentTarget;
    console.log("clicked");
    e.preventDefault();
      calcStart(item);
      //animateClick(item, initialValue);
    });
  });

  
});
}

function setImageSize (image) {
  console.log("setimagesize");
  let imageWrapper = image.parentNode;
  let wrapperMargin = parseInt(getComputedStyle(imageWrapper).marginTop);
  let ratio = image.naturalHeight / imageWrapper.offsetHeight;
  let imageHeight = (image.naturalHeight / ratio) * .7;
  let imageWidth = (image.naturalWidth / ratio) * .7;

  image.style.height = imageHeight + "px";
  image.style.width = imageWidth + "px";

  //console.log(gridgrowWidth);
  image.style.top = (imageWrapper.offsetHeight - wrapperMargin - imageHeight) / 2 + "px";
  image.style.left = (imageWrapper.offsetWidth - imageWidth) / 2 + "px";
  //console.log("height: " + imageHeight);
  
}


const gridContainerPadding = parseInt(getComputedStyle(gridContainer).paddingLeft)+ parseInt(getComputedStyle(gridContainer).paddingRight);
const containerPadding = parseInt(getComputedStyle(container).paddingLeft) + parseInt(getComputedStyle(container).paddingRight);
const containerWidth = parseInt(getComputedStyle(container).width) - containerPadding;
console.log("containerWidth: " + containerWidth);
const navHeight = document.querySelector(".masthead").offsetHeight;
//animateItem();

const pageUrl = window.location;

function calcStart(item) {
console.log("calcstart");
console.log(item);
    // I need to grab some starting values ON CLICK
    // Needs to be on click because some positions are based on the scroll offset
    let gridgrowWidth = item.offsetWidth;
    
    //console.log("RESIZING");
    let wipe = item.querySelector(".wipe");
    let wipeParent = item.querySelector(".gridgrow-image-holder");
    let itemImage = item.querySelector(".gridgrow-image");
    // 4. Useful if we have called disableBodyScroll for multiple target elements,
    // and we just want a kill-switch to undo all that.
    //bodyScrollLock.clearAllBodyScrollLocks();
    let scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
    //console.log("itemImage");
    //console.log(itemImage);
    
    let initialValue = {
        windowWidth: window.innerWidth,
        windowHeight: window.innerHeight,
        windowScrollX: window.scrollX,
        windowScrollY: window.scrollY,
        wrapperMarginTop: parseInt(getComputedStyle(wipeParent).marginTop),
        wrapperMarginLeft: -(parseInt(getComputedStyle(wipeParent).marginLeft)),
        containerPaddingLeft: containerPadding / 2,
        gridContainerPaddingLeft: gridContainerPadding / 2,
        wipe: {
          width: wipeParent.offsetWidth,
          height: wipeParent.offsetHeight,
          translateX: "0px",
          translateY: "0px",
          left: "0.1px",
          top: "0.1px",
          duration: 100,
          delay: 0,
          easing: "swing",
          z: wipe.style.zIndex,
        },
        item: {
          width: parseInt(itemImage.style.width),
          height: parseInt(itemImage.style.height),
          translateX: "0px",
          translateY: "0px",
          left: parseInt(itemImage.style.left),
          top: itemImage.offsetTop,
          backgroundPositionY: "60%",
          duration: 400,
          delay: 50,
          easing: "swing",
          z: itemImage.style.zIndex,
        },
        content: {
          top: 0,
        }
      }
        
      console.log("initial values:");
      console.log(initialValue);
      console.log(itemImage.style.width);
      //animateClick(e, initialValue);
      //calcEnd(initialValue);
      calcEnd(item, initialValue);
};

function calcEnd(item, initialValue) {

console.log("calcEnd:");
console.log(initialValue);
wipe = item.querySelector(".wipe");
itemImage = item.querySelector(".gridgrow-image");

// the final velocity values. To reverse animation, 

  let endValue = {
    windowWidth: window.innerWidth,
    windowHeight: window.innerHeight,
    windowScrollX: window.scrollX,
    windowScrollY: window.scrollY,
    wrapperMarginTop: initialValue.windowWidth,
    wrapperMarginLeft: "",
    wipe: {
        width: initialValue.windowWidth,
        height: (initialValue.windowHeight) + (initialValue.windowWidth * .2),
        translateX: -(item.offsetLeft + item.offsetParent.offsetLeft) - initialValue.windowScrollX,
        translateY: -((item.offsetTop + grid.offsetParent.offsetTop + initialValue.wrapperMarginTop) - initialValue.windowScrollY - navHeight),
        left: "0px",
        top: "0px",
        duration: 500,
        delay: 50,
        easing: "swing",
        z: 888
      },
      item: {
        width: initialValue.item.width * (containerWidth / initialValue.item.width),
        height: initialValue.item.height * (containerWidth / initialValue.item.width),
        // gridContainerPadding 20
        // 20 - 20 + 80 + 125 - 21 - 80
        translateX: -(item.offsetLeft - initialValue.gridContainerPaddingLeft + initialValue.item.left - initialValue.wrapperMarginLeft) + container.offsetLeft,
        translateY: -((item.offsetTop + grid.offsetParent.offsetTop + initialValue.wrapperMarginTop ) - initialValue.windowScrollY - navHeight),
        top: "0px",
        duration: 500,
        delay: 50,
        easing: "swing",
        z: 999
      },
      content: {
        top: 0,
      }
  }
  animateClick(item, initialValue, endValue);
}
// On click, grow the grid item and load the content
// On close, reverse the animation and hide the loaded content

function animateClick (item, initialValue, endValue) {

  console.log("INIT");
  //(e || window.event).preventDefault();
  //e.preventDefault();

  bodyScrollLock.disableBodyScroll(targetElement);

  //in some event handler after hiding the target element...
  //bodyScrollLock.enableBodyScroll(targetElement);

  //item = e.currentTarget;

  reverse = false
  item.removeEventListener("click", animateClick, false);
  animateItem(item, initialValue, endValue, reverse);
}

  //item.addEventListener("click", animateClick, false);

  //initialGridState();

  // window.addEventListener("resize", function(){
  //   // Resize the images based on the calculated values
  //   //console.log("resizeing");
  //   initialGridState();
  // });

  // window.addEventListener("resize", function() {
  //   //gridImageSize();
  //   initialGridState();
  // });

function animateItem(item, initialValue, endValue, reverse) {

  // don't want image to trigger click again
  //item.removeEventListener("click", animateClick, false);
  console.log("ANIMATION ITEM START ---------------------");
  console.log("initial values:");
  console.log(initialValue);
  // let windowHeight = initialValue.windowHeight;
  // let windowWidth = initialValue.windowWidth;
  

  //console.log("MATH:")
  //console.log(initialValue.wrapperMarginLeft);
  console.log("end values:");
  console.log(endValue);
  // change start values based on if the animation is being reversed

  let startValue;
  if (reverse) {

    startValue = endValue;
    endValue = initialValue;
    item.classList.remove("active");

  } else {

    startValue = initialValue;
    endValue = endValue;
    item.classList.add("active");
    itemImage.style.zIndex = 999;
    wipe.style.zIndex = 888;
    item.style.overflow = "visible";
    item.querySelector(".gridwrap").style.overflow = "visible";
    item.querySelector(".gridgrow-image-holder").style.overflow = "visible";

  }
  // Start ajax loading the content
  ajaxWorkItem(item, animateClick, initialValue, endValue, reverse);

  wipe.velocity({
    width: [endValue.wipe.width, startValue.wipe.width],
    height: [endValue.wipe.height, startValue.wipe.height],
    transform: [`translateX(${endValue.wipe.translateX}px) translateY(${endValue.wipe.translateY}px)`, `translateX(${startValue.wipe.translateX}px) translateY(${startValue.wipe.translateY}px)`],
    //transform: [endValue.scale, startValue.scale],
    left: [endValue.wipe.left, startValue.wipe.left],
    top: [endValue.wipe.top, startValue.wipe.top],
  }, 
  {
    delay: startValue.wipe.delay,
    duration: startValue.wipe.duration,
    easing: startValue.wipe.easing,
    /* Velocity's default options */
  });

  itemImage.velocity({
    transform: [`translateX(${endValue.item.translateX}px) translateY(${endValue.item.translateY}px)`, `translateX(${startValue.item.translateX}px) translateY(${startValue.item.translateY}px)`],
    //left: [`-${itemOffsetLeft}px`, `${itemOffsetLeft}px`],
    top: [endValue.item.top, startValue.item.top],
    bottom: [endValue.item.bottom, startValue.item.bottom],
    "background-position-y": [endValue.item.backgroundPositionY, startValue.item.backgroundPositionY],
    width: [endValue.item.width, startValue.item.width],
    height: [endValue.item.height, startValue.item.height]
  }, 
  {
    duration: startValue.item.duration,
    delay: startValue.item.delay,
    easing: startValue.item.easing,
    queue: "",
    loop: false,
    mobileHA: true,
    /* Velocity's default options */
    progress: function(elements, complete, remaining, start, tweenValue) {
      //console.log(complete);
      if (complete === 1) {
        //AOS.refresh();
        if (reverse) {
          item.style.overflow = "";
          item.querySelector(".gridwrap").style.overflow = "";
          item.querySelector(".gridgrow-image-holder").style.overflow = "";
          
          //gridImageSize();
          //initialGridState();
          bodyScrollLock.enableBodyScroll(targetElement);
          item.addEventListener("click", animateClick, false);
          itemImage.style.zIndex = "";
          wipe.style.zIndex = "";

        } else {
          reverseAnimation(item, initialValue, startValue, endValue, animateClick);
        }
      }
    }
  });

    
    
}
function reverseAnimation(item, initialValue, startValue, endValue, animateClick) {
  //window.location.href = window.location.origin;
  
  let reverseBtn = document.createElement("div");
  reverseBtn.classList.add("reverseAnimation");
  reverseBtn.innerHTML = `<span>Close</span><i class="fa fa-window-close" aria-hidden="true"></i>`;

  //reverseBtn.appendChild(t);
  document.body.appendChild(reverseBtn);

  //detect back btn then hijack it
  window.onpopstate = function(event) {
    window.history.pushState("object or string", "Title", pageUrl);
    reverseClick();
  }

  function reverseClick(e) {

    reverse = true;

    let element = document.querySelector(".reverseAnimation");
    element.parentNode.removeChild(element);

    animateItem(item, animateClick, initialValue, endValue, reverse);
    //clicky();
  }
  reverseBtn.addEventListener("click", reverseClick, false);     
      
}

function ajaxWorkItem (item, animateClick, initialValue, endValue, reverse) {

  if (reverse) {
    workAjax.innerHTML = "";
    workAjax
    .velocity({
      opacity: 0,
      visibility: ["hidden", "visible"]
    }, {
      duration: 400,
    })
    .velocity({
      display: "none",
    }, {
      duration: 0,
    });
  } else {
    let nextLink = item.querySelector("a").getAttribute("href");
      
    //https://stackoverflow.com/questions/36631762/returning-html-with-fetch
    // AJAX CALL
    
      fetch(nextLink /*, options */)
      .then((response) => response.text())
      .then((html) => {
          let parser = new DOMParser();

          // Parse the text
          var doc = parser.parseFromString(html, "text/html");
          var docArticle = doc.querySelector('main').innerHTML;
          workAjax.innerHTML = docArticle;
          //console.log(html);
          window.history.pushState("object or string", "Title", nextLink);
          
      })
      .catch((error) => {
          console.warn(error);
      });
      workAjax.velocity({
        top: [navHeight, 0],
        display: ["block", "none"]
      })
      workAjax
        .velocity({
          opacity: [1, 0],
          visibility: ["visible", "hidden"]
        }, {
          delay: 400,
          duration: 400,
        });
  }
  
}

}




</script>